var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Architectures","page":"Library Reference","title":"Architectures","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Architecture\narchitecture\nanswer_query\nanswer_query!","category":"page"},{"location":"api/#AlgebraicInference.Architecture","page":"Library Reference","title":"AlgebraicInference.Architecture","text":"Architecture{T₁, T₂} <: AbstractNode{T₁}\n\nAn Architecture contains a join tree (V E lambda D). To each vertex i in V it optionally associates a factor psi_i and mailbox\n\nleft( mu_i to mathttpa(i) mu_mathttpa(i) to i right)\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.architecture","page":"Library Reference","title":"AlgebraicInference.architecture","text":"architecture(kb::AbstractVector{<:Valuation{T}}, order) where T\n\nConstruct a covering join tree for the knowledge base kb using a variable elimination order order.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.answer_query","page":"Library Reference","title":"AlgebraicInference.answer_query","text":"answer_query(jt::Architecture{T₁, T₂}, query::Set{T₂}) where {T₁, T₂}\n\nAnswer a query.\n\nLet (V E lambda D) be a join tree with factors phi_i_i in V and x a query covered by (V E lambda D). Then answer_query(jt, query) solves the inference problem\n\nleft( bigotimes_i in V psi_i right)^downarrow x\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.answer_query!","page":"Library Reference","title":"AlgebraicInference.answer_query!","text":"answer_query!(jt::Architecture{T₁, T₂}, query::Set{T₂}) where {T₁, T₂}\n\nAnswer a query, caching intermediate computations.\n\nLet (V E lambda D) be a join tree with factors phi_i_i in V and x be a query covered by (V E lambda D). Then answer_query!(jt, query) solves the inference problem\n\nleft( bigotimes_i in V psi_i right)^downarrow x\n\n\n\n\n\n","category":"function"},{"location":"api/#Graphs","page":"Library Reference","title":"Graphs","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"primal_graph\nminfill!\nminwidth!","category":"page"},{"location":"api/#AlgebraicInference.primal_graph","page":"Library Reference","title":"AlgebraicInference.primal_graph","text":"primal_graph(kb::AbstractVector{<:Valuation{T}}) where T\n\nConstruct the primal graph of the knowledge base kb.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.minfill!","page":"Library Reference","title":"AlgebraicInference.minfill!","text":"minfill!(g::MetaGraph)\n\nCompute a vertex elimination order using the min-fill heuristic.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.minwidth!","page":"Library Reference","title":"AlgebraicInference.minwidth!","text":"minwidth!(g::MetaGraph)\n\nCompute a vertex elimination order using the min-width heuristic \n\n\n\n\n\n","category":"function"},{"location":"api/#Systems","page":"Library Reference","title":"Systems","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AbstractSystem\nAbstractProgram\nClosedProgram\nOpenProgram\nSystem\n\nClosedProgram(::AbstractMatrix, ::AbstractVector)\nClosedProgram(::AbstractMatrix)\nClosedProgram(::AbstractVector)\nOpenProgram(::ClosedProgram, ::AbstractMatrix, ::Int)\nOpenProgram(::ClosedProgram, ::AbstractMatrix)\nOpenProgram(::AbstractMatrix)\nSystem(::ClosedProgram, ::AbstractMatrix)\nSystem(::AbstractMatrix)\n\nlength(::AbstractSystem)\ndof(::AbstractSystem)\nfiber(::AbstractSystem)\nmean(::AbstractSystem)\ncov(::AbstractSystem)\n*(::AbstractMatrix, ::AbstractSystem)\n\\(::AbstractMatrix, ::AbstractSystem)\n⊗(::AbstractSystem, ::AbstractSystem)\noapply(::UndirectedWiringDiagram, ::AbstractDict{<:Any, <:AbstractSystem})\noapply(::UndirectedWiringDiagram, ::AbstractVector{<:AbstractSystem})","category":"page"},{"location":"api/#AlgebraicInference.AbstractSystem","page":"Library Reference","title":"AlgebraicInference.AbstractSystem","text":"AbstractSystem\n\nAbstract type for Gaussian systems.\n\nSubtypes should specialize the following methods:\n\nfiber(Σ::AbstractSystem)\nmean(Σ::AbstractSystem)\ncov(Σ::AbstractSystem)\n*(M::AbstractMatrix, Σ::AbstractSystem)\n\\(M::AbstractMatrix, Σ::AbstractSystem)\n⊗(Σ₁::AbstractSystem, Σ₂::AbstractSystem)\n\nReferences:\n\nJ. C. Willems, \"Open Stochastic Systems,\" in IEEE Transactions on Automatic Control,  vol. 58, no. 2, pp. 406-421, Feb. 2013, doi: 10.1109/TAC.2012.2210836.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.AbstractProgram","page":"Library Reference","title":"AlgebraicInference.AbstractProgram","text":"AbstractProgram <: AbstactSystem\n\nA program in the Gaussian probabilistic programming language. Every program\n\n    x R^m vdash e R^n\n\ncan be interepreted as a Gaussian system (mathbbR^m+n mathcalE P).\n\nReferences\n\nStein, Dario and Sam Staton. \"Compositional Semantics for Probabilistic Programs with Exact Conditioning.\" 2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS) (2021): 1-13.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.ClosedProgram","page":"Library Reference","title":"AlgebraicInference.ClosedProgram","text":"ClosedProgram{T₁ <: AbstractMatrix, T₂ <: AbstractVector} <: AbstractProgram\n\nA closed program vdash e R^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.OpenProgram","page":"Library Reference","title":"AlgebraicInference.OpenProgram","text":"OpenProgram{T₁, T₂, T₂ <: AbstractMatrix} <: AbstractProgram\n\nAn open program x R^m vdash e R^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.System","page":"Library Reference","title":"AlgebraicInference.System","text":"System{T₁ <: AbstractMatrix, T₂, T₃} <: AbstractSystem\n\nA Gaussian system. See AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.ClosedProgram-Tuple{AbstractMatrix, AbstractVector}","page":"Library Reference","title":"AlgebraicInference.ClosedProgram","text":"ClosedProgram(Γ::AbstractMatrix, μ::AbstractVector)\n\nConstruct a multivariate normal distribution with mean mu and covariance Gamma.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.ClosedProgram-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.ClosedProgram","text":"ClosedProgram(Γ::AbstractMatrix)\n\nConstruct a centered multivariate normal distribution with covariance Gamma.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.ClosedProgram-Tuple{AbstractVector}","page":"Library Reference","title":"AlgebraicInference.ClosedProgram","text":"ClosedProgram(μ::AbstractVector)\n\nConstruct a Dirac distribution with mean mu.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenProgram-Tuple{ClosedProgram, AbstractMatrix, Int64}","page":"Library Reference","title":"AlgebraicInference.OpenProgram","text":"OpenProgram(ϵ::ClosedProgram, L::AbstractMatrix, o::Int)\n\nLet vdash epsilon  R^n * R^o be a closed program and L an (n + o) times m matrix. Then OpenProgram(ϵ, L, o) constructs the open program\n\n    x R^m vdash textlet  (y k) R^n * R^o = Lx + epsilon text in \n    (k = mathbb0) y\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenProgram-Tuple{ClosedProgram, AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.OpenProgram","text":"OpenProgram(ϵ::ClosedProgram, L::AbstractMatrix)\n\nLet vdash epsilon  R^n be a closed program and L an m times n matrix. Then OpenProgram(ϵ, L) constructs the open program\n\n    x R^m vdash Lx + epsilon\n\nIn particular, if epsilon = mathcalN(mu Gamma), then OpenProgram(ϵ, L) constructs the conditional probability distribution\n\n    (y mid x) sim mathcalN(mu + Lx Gamma)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenProgram-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.OpenProgram","text":"OpenProgram(L::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.System-Tuple{ClosedProgram, AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.System","text":"System(ϵ::ClosedProgram, R::AbstractMatrix)\n\nLet R be an m times n matrix and epsilon an m-variate random vector with mean mu and covariance Gamma.\n\nIf mu in mathttimage(R  Gamma), then there exists a random variable hatw taking values in (mathbbR^n sigma R) that almost-surely solves the convex program\n\n    beginalign*\n        undersetwtextminimize   E(epsilon w) \n        textsubject to                Rw in mathttimage(Gamma) + epsilon\n    endalign*\n\nwhere\n\n    sigma R =  R^-1B mid B in mathcalB(mathbbR^m) \n\n\nand E(- w) is the negative log-density of the multivariate normal distribution mathcalN(Rw Gamma).\n\nIf mu in mathttimage(R  Gamma), then System(R, ϵ) constructs the Gaussian system Sigma = (mathbbR^n sigma R P), where P is the distribution of hatw.\n\nIn particular, if R has full row-rank, then Rw = epsilon is a kernel representation of Sigma.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.System-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.System","text":"System(R::AbstractMatrix)\n\nLet R be an m times n matrix. Then System(R) constructs the deterministic Gaussian system  Sigma = (mathbbR^n sigma R P) where\n\n    sigma R =  R^-1B mid B in mathcalB(mathbbR^m)\n\nand\n\n    P(R^-1B) = begincases\n        1  0 in B     \n        0  textelse\n    endcases\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{AbstractSystem}","page":"Library Reference","title":"Base.length","text":"length(Σ::AbstractSystem)\n\nLet Sigma = (mathbbR^n mathcalE P). Then length(Σ) gets the dimension n.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.dof-Tuple{AbstractSystem}","page":"Library Reference","title":"StatsAPI.dof","text":"dof(Σ::AbstractSystem)\n\nGet the number of degrees of freedom of Σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.fiber-Tuple{AbstractSystem}","page":"Library Reference","title":"AlgebraicInference.fiber","text":"fiber(Σ::AbstractSystem)\n\nCompute a basis for the fiber of Σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.mean-Tuple{AbstractSystem}","page":"Library Reference","title":"Statistics.mean","text":"mean(Σ::AbstractSystem)\n\nLet Rw = epsilon be any kernel representation of Sigma. Then mean(Σ) computes a vector mu such that Rmu is the mean of epsilon.\n\nIn particular, if Sigma is a classical Gaussian system, then mu is the mean of Sigma.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.cov-Tuple{AbstractSystem}","page":"Library Reference","title":"Statistics.cov","text":"cov(Σ::AbstractSystem)\n\nLet Rw = epsilon be any kernel representation of Sigma. Then cov(Σ) computes a matrix Gamma such that R Gamma R^mathsfT is the covariance of epsilon.\n\nIn particular, if Sigma is a classical Gaussian system, then Gamma is the covariance of Sigma.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Tuple{AbstractMatrix, AbstractSystem}","page":"Library Reference","title":"Base.:*","text":"*(M::AbstractMatrix, Σ::AbstractSystem)\n\nLet M be an n times m matrix, and let Sigma = (mathbbR^m mathcalE P). Then M * Σ computes the Gaussian system Sigma = (mathbbR^n mathcalE P), where\n\n    mathcalE =  B in mathcalB(mathbbR^n) mid M^-1B in mathcalE \n\nand\n\n    P(B) = P(M^-1B)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:\\-Tuple{AbstractMatrix, AbstractSystem}","page":"Library Reference","title":"Base.:\\","text":"\\(M::AbstractMatrix, Σ::AbstractSystem)\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.Theories.:⊗-Tuple{AbstractSystem, AbstractSystem}","page":"Library Reference","title":"Catlab.Theories.:⊗","text":"⊗(Σ₁::AbstractSystem, Σ₂::AbstractSystem)\n\nCompute the product Sigma_1 times Sigma_2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply-Tuple{AbstractUWD, AbstractDict{<:Any, <:AbstractSystem}}","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"oapply(wd::UndirectedWiringDiagram, box_map::AbstractDict{<:Any, <:AbstractSystem})\n\nSee oapply(wd::UndirectedWiringDiagram, box_map::AbstractVector{<:AbstractSystem}).\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply-Tuple{AbstractUWD, AbstractVector{<:AbstractSystem}}","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"oapply(wd::UndirectedWiringDiagram, boxes::AbstractVector{<:AbstractSystem})\n\nCompose Gaussian systems according to the undirected wiring diagram wd.\n\n\n\n\n\n","category":"method"},{"location":"api/#Valuations","page":"Library Reference","title":"Valuations","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Valuation\nIdentityValuation\nLabeledBox\n\ndomain\ncombine\nproject\n\ninference_problem(::UndirectedWiringDiagram, ::AbstractDict)\ninference_problem(::UndirectedWiringDiagram, ::AbstractVector)","category":"page"},{"location":"api/#AlgebraicInference.Valuation","page":"Library Reference","title":"AlgebraicInference.Valuation","text":"Valuation{T}\n\nAbstract type for valuations in a valuation algebra.\n\nSubtypes should specialize the following methods:\n\ndomain(ϕ::Valuation)\ncombine(ϕ₁::Valuation, ϕ₂::Valuation)\nproject(ϕ::Valuation, x)\n\nValuations are parametrized by the type of the variables in their variable system. If ϕ <: Valuation{T}, then domain(ϕ) should return a container with element type T.\n\nReferences:\n\nPouly, M.; Kohlas, J. Generic Inference. A Unified Theory for Automated Reasoning; Wiley: Hoboken, NJ, USA, 2011.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.IdentityValuation","page":"Library Reference","title":"AlgebraicInference.IdentityValuation","text":"IdentityValuation{T} <: Valuation{T}\n\nThe identity element e.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.LabeledBox","page":"Library Reference","title":"AlgebraicInference.LabeledBox","text":"LabeledBox{T₁, T₂} <: Valuation{T₁}\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.domain","page":"Library Reference","title":"AlgebraicInference.domain","text":"domain(ϕ::Valuation)\n\nGet the domain of phi.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.combine","page":"Library Reference","title":"AlgebraicInference.combine","text":"combine(ϕ₁::Valuation, ϕ₂::Valuation)\n\nPerform the combination phi_1 otimes phi_2.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.project","page":"Library Reference","title":"AlgebraicInference.project","text":"project(ϕ::Valuation, x)\n\nPerform the projection phi^downarrow x.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.inference_problem-Tuple{AbstractUWD, AbstractDict}","page":"Library Reference","title":"AlgebraicInference.inference_problem","text":"inference_problem(wd::UndirectedWiringDiagram, box_map::AbstractDict)\n\nSee inference_problem(wd::UndirectedWiringDiagram, boxes::AbstractVector).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.inference_problem-Tuple{AbstractUWD, AbstractVector}","page":"Library Reference","title":"AlgebraicInference.inference_problem","text":"inference_problem(wd::UndirectedWiringDiagram, boxes::AbstractVector)\n\nLet f be an operation in Cospan of the form\n\n    B xleftarrowmathttbox P xrightarrowmathttjunc J\n    xleftarrowmathttjunc Q\n\nand (b_1 dots b_n) a sequence of fillers for the boxes in f. Then inference_problem(wd, boxes) constructs a knowledge base phi_1 dots phi_n and query x subseteq J such that\n\n    (phi_1 otimes dots otimes phi_n)^downarrow x cong\n    F(f)(b_1 dots b_n)\n\nwhere F is the Cospan-algebra computed by oapply.\n\nThe operation f must satify must satisfy the following constraints:\n\nmathttjunc is injective.\nmathttimage(mathttjunc) subseteq mathttimage(mathttjunc)\nFor all x y in P, mathttbox(x) = mathttbox(y) and mathttjunc(x) = mathttjunc(y) implies that x = y. \n\n\n\n\n\n","category":"method"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/regression.jl\"","category":"page"},{"location":"generated/regression/#Linear-Regression","page":"Linear Regression","title":"Linear Regression","text":"","category":"section"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"using AlgebraicInference\nusing Catlab, Catlab.Graphics, Catlab.Programs\nusing LinearAlgebra\nusing StatsPlots","category":"page"},{"location":"generated/regression/#Frequentist-Linear-Regression","page":"Linear Regression","title":"Frequentist Linear Regression","text":"","category":"section"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Consider the Gauss-Markov linear model","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"    y = X beta + epsilon","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"where X is an n times m matrix, beta is an m times 1 vector, and epsilon is an n times 1 normally distributed random vector with mean mathbf0 and covariance W. If X has full column rank, then the best linear unbiased estimator for beta is the random vector","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"    hatbeta = X^+ (I - (Q W Q)^+ Q W)^mathsfT y","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"where X^+ is the Moore-Penrose psuedoinverse of X, and","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Q = I - X X^+","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"References:","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Albert, Arthur. \"The Gauss-Markov Theorem for Regression Models with Possibly Singular Covariances.\" SIAM Journal on Applied Mathematics, vol. 24, no. 2, 1973, pp. 182–87.","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"X = [\n    1 0\n    0 1\n    0 0\n]\n\nW = [\n    1 0 0\n    0 1 0\n    0 0 1\n]\n\ny = [\n    1\n    1\n    1\n]\n\nQ = I - X * pinv(X)\nβ̂ = pinv(X) * (I - pinv(Q * W * Q) * Q * W)' * y","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"To solve for hatbeta using AlgebraicInference.jl, we construct an undirected wiring diagram.","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"diagram = @relation (a₁, a₂) begin\n    X(a₁, a₂, b₁, b₂, b₃)\n    +(b₁, b₂, b₃, c₁, c₂, c₃, d₁, d₂, d₃)\n    ϵ(c₁, c₂, c₃)\n    y(d₁, d₂, d₃)\nend\n\nto_graphviz(diagram; box_labels=:name, implicit_junctions=true)","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Then we assign values to the boxes in diagram and compute the result.","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"P = [\n    1 0 0 1 0 0\n    0 1 0 0 1 0\n    0 0 1 0 0 1\n]\n\nhom_map = Dict(\n    :X => OpenProgram(X),\n    :+ => OpenProgram(P),\n    :ϵ => ClosedProgram(W),\n    :y => ClosedProgram(y))\n\nβ̂ = mean(oapply(diagram, hom_map))","category":"page"},{"location":"generated/regression/#Bayesian-Linear-Regression","page":"Linear Regression","title":"Bayesian Linear Regression","text":"","category":"section"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Let rho = mathcalN(m V) be our prior belief about beta. Then our posterior belief hatrho is a bivariate normal distribution with mean","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"  hatm = m - V X^mathsfT (X V X + W)^+ (X m - y)","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"and covariance","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"  hatV = V - V X^mathsfT (X V X + W)^+ X V","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"V = [\n    1 0\n    0 1\n]\n\nm = [\n    0\n    0\n]\n\nm̂ = m - V * X' * pinv(X * V * X' + W) * (X * m - y)","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"V̂ = V - V * X' * pinv(X * V * X' + W) * X * V","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"To solve for hatrho using AlgebraicInference.jl, we construct an undirected wiring diagram.","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"diagram = @relation (a₁, a₂) begin\n    ρ(a₁, a₂)\n    X(a₁, a₂, b₁, b₂, b₃)\n    +(b₁, b₂, b₃, c₁, c₂, c₃, d₁, d₂, d₃)\n    ϵ(c₁, c₂, c₃)\n    y(d₁, d₂, d₃)\nend\n\nto_graphviz(diagram; box_labels=:name, implicit_junctions=true)","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"Then we assign values to the boxes in diagram and compute the result.","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"hom_map = Dict(\n    :ρ => ClosedProgram(V, m),\n    :X => OpenProgram(X),\n    :+ => OpenProgram(P),\n    :ϵ => ClosedProgram(W),\n    :y => ClosedProgram(y))\n\nm̂ = mean(oapply(diagram, hom_map))","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"V̂ = cov(oapply(diagram, hom_map))","category":"page"},{"location":"generated/regression/","page":"Linear Regression","title":"Linear Regression","text":"covellipse!(m, V, aspect_ratio=:equal, label=\"prior\")\ncovellipse!(m̂, V̂, aspect_ratio=:equal, label=\"posterior\")","category":"page"},{"location":"#AlgebraicInference.jl","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"","category":"section"},{"location":"","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"AlgebraicInference.jl is a library for compositional Bayesian inference. It builds on Catlab.jl.","category":"page"}]
}
