var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Gaussian-Relations","page":"Library Reference","title":"Gaussian Relations","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"GaussianDistribution\nGaussianDistribution(Q::AbstractMatrix)\nGaussianDistribution(a::AbstractVector)\n\nGaussianRelation\nGaussianRelation(L::AbstractMatrix)\nGaussianRelation(ψ::GaussianDistribution)\n\nGaussRelDom\n\nparams\ncov\nmean","category":"page"},{"location":"api/#AlgebraicInference.GaussianDistribution","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(Q, a)\n\nA Gaussian distribution with covariance Q and mean a.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.GaussianDistribution-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(Q::AbstractMatrix)\n\nConstruct a centered Gaussian distribution with covariance Q.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussianDistribution-Tuple{AbstractVector}","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(a::AbstractVector)\n\nConstruct a Dirac distribution with mean a.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussianRelation","page":"Library Reference","title":"AlgebraicInference.GaussianRelation","text":"GaussianRelation(rf)\n\nA Gaussian relation is a morphism in the hypergraph category textCond(textGaussEx). Internally, it is represented as an equivalence class of partial quadratic bifunctions, where \n\nF_1 sim F_2 iff F_1 = F_2 + alpha text for some  alpha in mathbbR\n\nstruct GaussianRelation{T₁, T₂, T₃, T₄}\n    rf::QuadraticBifunction{T₁, T₂, T₃, T₄}\nend\n\nEvery Gaussian relation d m to n is either an extended Gaussian distribution on mathbbR^m + n or a failure state bot_m + n.\n\nReferences:\n\nStein & Staton (2021), \"Compositional Semantics for Probabilistic Programs with Exact Conditioning\" (arXiv:2101.11351)\nStein (2022), \"Decorated Linear Relations: Extending Gaussian Probability with Uninformative Priors\" (arXiv:2204.14024)\nStein (2022), \"A Hypergraph Category for Exact Gaussian Inference\", (https://msp.cis.strath.ac.uk/act2022/papers/ACT2022paper3601.pdf)\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.GaussianRelation-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.GaussianRelation","text":"GaussianRelation(L::AbstractMatrix)\n\nConstruct the extended Gaussian distribution\n\nmathcalN(0 0) +  (x y) mid Lx = y \n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussianRelation-Tuple{QuadraticFunction}","page":"Library Reference","title":"AlgebraicInference.GaussianRelation","text":"GaussianRelation(ψ::GaussianDistribution)\n\nConstruct the extended Gaussian distribution psi +  0 .\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussRelDom","page":"Library Reference","title":"AlgebraicInference.GaussRelDom","text":"GaussRelDom(n)\n\nThe Euclidean space mathbbR^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.params","page":"Library Reference","title":"StatsAPI.params","text":"params(d::GaussianRelation)\n\nRepresent d as an extended Gaussian distribution.\n\nReturns a quadruple (Q a B b). If b neq 0, then d = bot. Otherwise,\n\nd = mathcalN(a Q) + textnull  B\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.cov","page":"Library Reference","title":"Statistics.cov","text":"cov(ψ::GaussianDistribution)\n\nGet the covariance of ψ.\n\n\n\n\n\ncov(d::GaussianRelation)\n\nGet the covariance of d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean","page":"Library Reference","title":"Statistics.mean","text":"mean(ψ::GaussianDistribution)\n\nGet the mean of ψ.\n\n\n\n\n\nmean(d::GaussianRelation)\n\nGet the mean of d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quadratic-Functions","page":"Library Reference","title":"Quadratic Functions","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"QuadraticFunction\nQuadraticFunction(Q::AbstractMatrix)\nQuadraticFunction(a::AbstractVector)\n\nQuadraticBifunction\nQuadraticBifunction(L::AbstractMatrix)\nQuadraticBifunction(f::QuadraticFunction)\n\nQuadDom\n\n*\nconjugate\n\ndom\ncodom\nmzero\ndagger\ncompose\noplus\nmeet\njoin\nid\nzero\ndelete\nmcopy\nplus\ndunit\ncozero\ncreate\nmmerge\ncoplus\ndcounit\nswap\ntop\nbottom","category":"page"},{"location":"api/#AlgebraicInference.QuadraticFunction","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(Q, a)\n\nA quadratic function of the form\n\nf(x) = langle x Qx + a rangle\n\nwhere Q is positive semidefinite.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.QuadraticFunction-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(Q::AbstractMatrix)\n\nConstruct the quadratic function f(x) = langle x Qx rangle, where Q is positive semidefinite.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadraticFunction-Tuple{AbstractVector}","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(a::AbstractVector)\n\nConstruct the linear function f(x) = langle x a rangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadraticBifunction","page":"Library Reference","title":"AlgebraicInference.QuadraticBifunction","text":"QuadraticBifunction(L, R, f)\n\nA partial quadratic bifunction F m to n is a convex function on mathbbR^m + n of the form\n\nF(x y) = begincases\n    langle (x y) Q(x y) + a rangle + alpha    B(x y) = b \n    infty                                  textelse\nendcases\n\nwhere Q is positive semidefinite. Internally, F is represented by a triple (L R f) such that\n\nF(x y) = f^*(Ry - Lx)\n\nwhere f^* is the convex conjuate of f.\n\nstruct QuadraticBifunction{T₁ <: AbstractMatrix, T₂ <: AbstractMatrix, T₃, T₄}\n    L::T₁\n    R::T₂\n    f::QuadraticFunction{T₃, T₄}\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.QuadraticBifunction-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.QuadraticBifunction","text":"QuadraticBifunction(L::AbstractMatrix)\n\nConstruct the indicator bifunction corresponding to L, given by\n\nF(x y) = begincases\n0        Lx = y \ninfty  textelse\nendcases\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadraticBifunction-Tuple{QuadraticFunction}","page":"Library Reference","title":"AlgebraicInference.QuadraticBifunction","text":"QuadraticBifunction(f::QuadraticFunction)\n\nConstruct the bifunction F(* y) = f^*(y), where f^* is the convex conjugate of f.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadDom","page":"Library Reference","title":"AlgebraicInference.QuadDom","text":"QuadDom(n)\n\nThe Euclidian space mathbbR^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*","page":"Library Reference","title":"Base.:*","text":"*(f::QuadraticFunction, M::Union{UniformScaling, AbstractMatrix})\n\nCompute the inverse image of f under M, given by\n\n(fM)(y) = f(My)\n\n\n\n\n\n*(M::Union{UniformScaling, AbstractMatrix}, f::QuadraticFunction)\n\nCompute the image of f under M, given by\n\n(Mf)(y) = inf  f(x) mid y = Mx \n\nReturns a quintuple (Q a alpha B b) If b neq 0, then Mf = -infty. Otherwise,\n\n(Mf)(y) = begincases\n    langle y frac12Qy + a rangle + alpha     By = 0 \n    infty                                      textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.conjugate","page":"Library Reference","title":"AlgebraicInference.conjugate","text":"conjugate(F::QuadraticBifunction)\n\nCompute the convex conjugate of F, given by\n\nF^*(x^* y^*) = sup  langle y y^* rangle - langle x x^* rangle - F(x y) mid x y \n\nReturns a quintuple (Q a alpha B b) If b neq 0, then F^* = -infty. Otherwise,\n\nF^*(x^* y^*) = begincases\n    langle (x^* y^*) frac12Q(x^* y^*) + a rangle + alpha  By^* = 0 \n    infty                                                      textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Schemas.dom","page":"Library Reference","title":"Catlab.Schemas.dom","text":"dom(F::QuadraticBifunction)\n\nThe domain of a bifunction is the dimension of its first variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Schemas.codom","page":"Library Reference","title":"Catlab.Schemas.codom","text":"codom(F::QuadraticBifunction)\n\nThe codomain of a bifunction is the dimension of its second variable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.mzero","page":"Library Reference","title":"Catlab.Theories.mzero","text":"mzero(::Type{QuadDom})\n\nThe Euclidean space mathbbR^0.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dagger","page":"Library Reference","title":"Catlab.Theories.dagger","text":"dagger(F::QuadraticBifunction)\n\nCompute the dagger of F, given by\n\nF^dagger(y x) = F(x y)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.compose","page":"Library Reference","title":"Catlab.Theories.compose","text":"compose(F₁::QuadraticBifunction, F₂::QuadraticFunction)\n\nCompute the product of F₁ and F₂, given by\n\n    (F_2F_1)(x z) = sup  F_1(x y) + F_2(y z) mid y \n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.oplus","page":"Library Reference","title":"Catlab.Theories.oplus","text":"oplus(f₁::QuadraticFunction, f₂::QuadraticFunction)\n\nCompute the direct sum of f₁ and f₂, given by \n\n(f_1 oplus f_2)(x y) = f_1(x) + f_2(y)\n\n\n\n\n\noplus(X::QuadDom, Y::QuadDom)\n\nCompute the direct sum of X and Y.\n\n\n\n\n\noplus(F₁::QuadraticBifunction, F₂::QuadraticBifunction)\n\nCompute the direct sum of F₁ and F₂, given by\n\n    (F_1 oplus F_2)((x_1 x_2) (y_1 y_2)) = F_1(x_1 y_1) + F_2(x_2 y_2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.meet","page":"Library Reference","title":"Catlab.Theories.meet","text":"meet(F₁::QuadraticBifunction, F₂::QuadraticBifunction)\n\nCompute the sum of F₁ and F₂, given by\n\n    (F_1 + F_2)(x y) = F_1(x y) + F_2(x y)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.join","page":"Library Reference","title":"Base.join","text":"join(F₁::QuadraticBifunction, F₂::QuadraticBifunction)\n\nCompute the infimal convolution of F₁  and F₂, given by\n\n    (F_1 Box F_2)(x^* y^*) = inf  F_1(x^* y^*) + F_2(x - x^* y - y^*) mid x y \n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.id","page":"Library Reference","title":"Catlab.Theories.id","text":"id(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x y) = begincases\n    0        x = y \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zero","page":"Library Reference","title":"Base.zero","text":"zero(X::QuadDom)\n\nConstruct the indicator bifunction F(* y) = 0\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.delete","page":"Library Reference","title":"Catlab.Theories.delete","text":"delete(X::QuadDom)\n\nConstruct the indicator bifunction F(x *) = 0\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.mcopy","page":"Library Reference","title":"Catlab.Theories.mcopy","text":"mcopy(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x (y_1 y_2)) = begincases\n    0        x = y_1 = y_2 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.plus","page":"Library Reference","title":"Catlab.Theories.plus","text":"plus(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) = begincases\n    0        x_1 + x_2 = y \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dunit","page":"Library Reference","title":"Catlab.Theories.dunit","text":"dunit(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(* (y_1 y_2)) = begincases\n    0        y_1 = y_2 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.cozero","page":"Library Reference","title":"Catlab.Theories.cozero","text":"cozero(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x *) = begincases\n    0        x = 0 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.create","page":"Library Reference","title":"Catlab.Theories.create","text":"create(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(* y) = begincases\n    0        y = 0 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.mmerge","page":"Library Reference","title":"Catlab.Theories.mmerge","text":"mmerge(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) = begincases\n    0        x_1 = x_2 = y \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.coplus","page":"Library Reference","title":"Catlab.Theories.coplus","text":"coplus(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) = begincases\n    0        x_1 + x_2 = y \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dcounit","page":"Library Reference","title":"Catlab.Theories.dcounit","text":"dcounit(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) *) = begincases\n    0        x_1 = x_2 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.swap","page":"Library Reference","title":"Catlab.Theories.swap","text":"swap(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) (y_1 y_2)) = begincases\n    0        x_1 = y_2 x_2 = y_1 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.top","page":"Library Reference","title":"Catlab.Theories.top","text":"top(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x y) = begincases\n    0        x = y = 0 \n    infty  textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.bottom","page":"Library Reference","title":"Catlab.Theories.bottom","text":"bottom(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction F(x y) = 0\n\n\n\n\n\n","category":"function"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/regression.jl\"","category":"page"},{"location":"generated/regression/#Bayesian-Linear-Regression","page":"Examples","title":"Bayesian Linear Regression","text":"","category":"section"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing Convex\nusing DataFrames\nusing Fontconfig\nusing Gadfly\nusing LinearAlgebra: I\nusing SCS\nusing TikzPictures","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"The diagram update_diagram represents the posterior distribution of a Bayesian linear regression model.","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"const F = FreeAbelianBicategoryRelations\n\ninput_space  = Ob(F, :input_space)\noutput_space = Ob(F, :output_space)\ninput        = Hom(:input, input_space, output_space)\noutput       = Hom(:output, mzero(F.Ob), output_space)\nerror        = Hom(:error, mzero(F.Ob), output_space)\nweights      = Hom(:weights, mzero(F.Ob), input_space)\n\nupdate_diagram = (\n    weights\n    ⋅ Δ(input_space)\n    ⋅ (error ⊕ input ⊕ id(input_space))\n    ⋅ (plus(output_space) ⊕ id(input_space))\n    ⋅ (output ⊕ id(output_space) ⊕ id(input_space))\n    ⋅ (dcounit(output_space) ⊕ id(input_space))\n)\n\nto_tikz(update_diagram; base_unit=\"8mm\")","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"The diagram predict_diagram represents the predictive distribution of a Bayesian linear regression model.","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"predict_diagram = (\n    weights\n    ⋅ (error ⊕ input)\n    ⋅ plus(output_space)\n)\n\nto_tikz(predict_diagram; base_unit=\"8mm\")","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"Inputs are transformed by nine Gaussian basis functions.","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"gbf(μ, s, x) = exp(-(x - μ)^2 / s^2 / 2)\nϕ(x) = [gbf(0.0, 0.1, x) gbf(0.5, 0.1, x) gbf(1.0, 0.1, x) gbf(0.0, 0.5, x) gbf(0.5, 0.5, x) gbf(1.0, 0.5, x) gbf(0.0, 2.5, x) gbf(0.5, 2.5, x) gbf(1.0, 2.5, x)];\nnothing #hide","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"The error term is a centered Gaussian distribution with variance 004.","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"\"\"\"\n    update(w, x, y)\n\nUpdate weights `w` given input `x` and output `y`.\n\"\"\"\nfunction update(w, x, y)\n    types = (GaussRelDom, GaussianRelation)\n\n    generators = Dict(\n        weights      => w,\n        input_space  => GaussRelDom(9),\n        output_space => GaussRelDom(1),\n        input        => GaussianRelation(ϕ(x)),\n        output       => GaussianRelation(GaussianDistribution([y])),\n        error        => GaussianRelation(GaussianDistribution(Matrix(0.04I, 1, 1))),\n    )\n\n    functor(types, update_diagram; generators)\nend\n\n\"\"\"\n    predict(w, x)\n\nPredict an output given weights `w` and an input `x`.\n\nReturns a tuple `(μ, σ)`, representing the center and spread of the prediction.\n\"\"\"\nfunction predict(w, x)\n    types = (GaussRelDom, GaussianRelation)\n\n    generators = Dict(\n        weights      => w,\n        input_space  => GaussRelDom(9),\n        output_space => GaussRelDom(1),\n        input        => GaussianRelation(ϕ(x)),\n        error        => GaussianRelation(GaussianDistribution(Matrix(0.04I, 1, 1))),\n    )\n\n    functor(types, predict_diagram; generators)\nend\n\n\"\"\"\n    plot_predictions(w, xs, ys)\n\nPlot predicted outputs against true outputs and observations.\n\"\"\"\nfunction plot_predictions(w, xs, ys)\n    D₁ = DataFrame(x=xs, y=ys)\n    D₂ = DataFrame(map(range(0, 1, 50)) do x\n        Σ, μ, _... = params(predict(w, x))\n        ytrue = sin(2π * x)\n        ypred = μ[1]\n        ymin = ypred - √abs(Σ[1, 1])\n        ymax = ypred + √abs(Σ[1, 1])\n        (x=x, ytrue=ytrue, ypred=ypred, ymin=ymin, ymax=ymax)\n    end)\n\n    plot(\n        layer(D₁, x=:x, y=:y, color=[colorant\"black\"], Geom.point),\n        layer(D₂, x=:x, y=:ytrue, color=[colorant\"black\"], Geom.line),\n        layer(D₂, x=:x, y=:ypred, ymin=:ymin, ymax=:ymax, color=[colorant\"red\"], Geom.line, Geom.ribbon),\n        Coord.cartesian(xmin=0, xmax=1, ymin=-2, ymax=2),\n        Guide.xlabel(\"\"),\n        Guide.ylabel(\"\"),\n    )\nend;\nnothing #hide","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"The prior over the weights is a centered Gaussian distribution with covariance matrix 05I.","category":"page"},{"location":"generated/regression/","page":"Examples","title":"Examples","text":"xs = [0.76, 0.50, 0.93, 0.38, 0.22, 0.98, 0.92, 0.39, 0.32, 0.34, 0.46, 0.10, 0.37, 0.08, 0.16, 0.97, 0.69, 0.63, 0.77, 0.23]\nys = [-1.03, -0.02, -0.31, 0.51, 0.80, -0.02, -0.28, 0.79, 0.80, 0.70, 0.21, 0.71, 0.93, 0.58, 0.77, -0.29, -1.11, -0.86, -1.06, 1.00]\nws = []\n\npush!(ws, GaussianRelation(GaussianDistribution(Matrix(0.5I, 9, 9))))\nfor (x, y) in zip(xs, ys)\n    push!(ws, update(ws[end], x, y))\nend\n\np₁ = plot_predictions(ws[2], xs[1:1], ys[1:1])\np₂ = plot_predictions(ws[3], xs[1:2], ys[1:2])\np₃ = plot_predictions(ws[5], xs[1:4], ys[1:4])\np₄ = plot_predictions(ws[21], xs[1:20], ys[1:20])\n\nset_default_plot_size(21cm, 16cm)\ngridstack([p₁ p₂; p₃ p₄])","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"EditURL = \"<unknown>/literate/kalman.jl\"","category":"page"},{"location":"generated/kalman/#Kalman-Filter","page":"Kalman Filter","title":"Kalman Filter","text":"","category":"section"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"Constructing the Kalman filter described in Example 9 – Vehicle Location Estimation.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"using AlgebraicInference\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.WiringDiagrams\nimport Convex, SCS\nimport TikzPictures","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"First, we construct a diagram representing the filter's prediction step.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"O = mzero(FreeAbelianBicategoryRelations.Ob)\nX = Ob(FreeAbelianBicategoryRelations, :X)\nQ = Hom(:Q, O, X)\nF = Hom(:F, X, X)\n\nkalman_predict = (F ⊕ Q) ⋅ plus(X)\nto_tikz(kalman_predict)","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"Next, we construct a diagram representing the filter's observation step.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"Z = Ob(FreeAbelianBicategoryRelations, :Z)\nR = Hom(:R, O, Z)\nH = Hom(:H, X, Z)\n\nkalman_observe = Δ(X) ⋅ (id(X) ⊕ H ⊕ R) ⋅ (id(X) ⊕ plus(Z))\nto_tikz(kalman_observe)","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"Finally, we construct a diagram representing two iterations of the filter.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"P₀ = Hom(:P_0, O, X)\nz₁ = Hom(:z_1, O, Z)\nz₂ = Hom(:z_2, O, Z)\n\nkalman_filter = P₀\nkalman_filter = kalman_filter ⋅ kalman_predict ⋅ kalman_observe ⋅ (id(X) ⊕ dagger(z₁))\nkalman_filter = kalman_filter ⋅ kalman_predict ⋅ kalman_observe ⋅ (id(X) ⊕ dagger(z₂))\nto_tikz(kalman_filter)","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"To perform a computation, we assign data to the boxes and wires of our filter diagram. The output is a Gaussian relation, representing the estimated state tat time t = 2 given observations z_1 and z_2.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"types = (GaussRelDom, GaussianRelation)\n\ngenerators = Dict(\n    X => GaussRelDom(6),\n    Z => GaussRelDom(2),\n    F => GaussianRelation([\n        1   1   1/2 0   0   0\n        0   1   1   0   0   0\n        0   0   1   0   0   0\n        0   0   0   1   1   1/2\n        0   0   0   0   1   1\n        0   0   0   0   0   1\n    ]),\n    H => GaussianRelation([\n        1   0   0   0   0   0\n        0   0   0   1   0   0\n    ]),\n    Q => GaussianRelation(GaussianDistribution([\n        1/4 1/2 1/2 0   0   0\n        1/2 1   1   0   0   0\n        1/2 1   1   0   0   0\n        0   0   0   1/4 1/2 1/2\n        0   0   0   1/2 1   1\n        0   0   0   1/2 1   1\n    ] * 1/25)),\n    R => GaussianRelation(GaussianDistribution([\n        9   0\n        0   9\n    ])),\n    P₀ => GaussianRelation(GaussianDistribution([\n        500 0   0   0   0   0\n        0   500 0   0   0   0\n        0   0   500 0   0   0\n        0   0   0   500 0   0\n        0   0   0   0   500 0\n        0   0   0   0   0   500\n    ])),\n    z₁ => GaussianRelation(GaussianDistribution([-393.66, 300.40])),\n    z₂ => GaussianRelation(GaussianDistribution([-375.93, 301.78])),\n)\n\nd = functor(types, kalman_filter; generators)","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"The covariance of the estimated state at time t = 2.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"round.(cov(d); digits=2)","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"The mean of the estimated state at time t = 2.","category":"page"},{"location":"generated/kalman/","page":"Kalman Filter","title":"Kalman Filter","text":"round.(mean(d); digits=2)","category":"page"},{"location":"#AlgebraicInference.jl","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"","category":"section"},{"location":"","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"AlgebraicInference.jl is a library for compositional Bayesian inference. It builds on Catlab.jl.","category":"page"}]
}
