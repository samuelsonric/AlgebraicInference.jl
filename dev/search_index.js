var documenterSearchIndex = {"docs":
[{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"EditURL = \"<unknown>/literate/filter.jl\"","category":"page"},{"location":"generated/filter/#Kalman-Filter","page":"Kalman Filter","title":"Kalman Filter","text":"","category":"section"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing DataFrames\nusing Fontconfig\nusing Gadfly\nusing LinearAlgebra: diag","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"The undirected wiring diagram filter_diagram represents five iterations of a one-dimensional Kalman filter.","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"filter_diagram = @relation (X₁, X₂, X₃, X₄, X₅) begin\n    s₀(X₀)\n    y₁(Y₁)\n    y₂(Y₂)\n    y₃(Y₃)\n    y₄(Y₄)\n    y₅(Y₅)\n    s(X₀, X₁)\n    s(X₁, X₂)\n    s(X₂, X₃)\n    s(X₃, X₄)\n    s(X₄, X₅)\n    m(X₁, Y₁)\n    m(X₂, Y₂)\n    m(X₃, Y₃)\n    m(X₄, Y₄)\n    m(X₅, Y₅)\nend\n\nto_graphviz(filter_diagram;\n    box_labels = :name,\n    graph_attrs = Dict(:size => \"6!\"),\n)","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"We assign values to the boxes in filter_diagram,","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"beginalign*\ns_0   = mathcalN(10 10000) \ns(x)  = mathcalN(x 015) \nm(x)  = mathcalN(x 001) \ny_1   = 50486 \ny_2   = 50963 \ny_3   = 51597 \ny_4   = 52001 \ny_5   = 52518\nendalign*","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"where (y_1 dots y_5) are noisy measurements of the points","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"(50505 50994 51493 52001 52506)","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"and estimate the state at times 1 leq t leq 5.","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"hom_map = Dict(\n    :s₀  => OpenGaussianDistribution(GaussianDistribution([10000;;], [10])),\n    :y₁  => OpenGaussianDistribution(GaussianDistribution([0;;], [50.486])),\n    :y₂  => OpenGaussianDistribution(GaussianDistribution([0;;], [50.963])),\n    :y₃  => OpenGaussianDistribution(GaussianDistribution([0;;], [51.597])),\n    :y₄  => OpenGaussianDistribution(GaussianDistribution([0;;], [52.001])),\n    :y₅  => OpenGaussianDistribution(GaussianDistribution([0;;], [52.518])),\n    :s   => OpenGaussianDistribution([1;;], GaussianDistribution([0.15;;], [0])),\n    :m   => OpenGaussianDistribution([1;;], GaussianDistribution([0.01;;], [0])),\n)\n\nstate = oapply(filter_diagram, hom_map)\nμ = mean(state)\nΣ = cov(state)\n\nround.(μ; digits=2)","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"round.(Σ; digits=2)","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"Finally, we plot estimates against measurements and true values.","category":"page"},{"location":"generated/filter/","page":"Kalman Filter","title":"Kalman Filter","text":"ys = DataFrame(Dict(\n    :x => 1:5,\n    :y_meas => [50.486, 50.963, 51.597, 52.001, 52.518],\n    :y_true => [50.505, 50.994, 51.493, 52.001, 52.506],\n    :y_pred => μ,\n    :y_max  => μ + 2(√).(diag(Σ)),\n    :y_min  => μ - 2(√).(diag(Σ)),\n))\n\nset_default_plot_size(23cm, 10cm)\n\nplot(\n    layer(ys, x=:x, y=:y_meas, color=[\"Measurement\"], Geom.point),\n    layer(ys, x=:x, y=:y_true, color=[\"True Value\"], Geom.line),\n    layer(ys, x=:x, y=:y_pred, color=[\"Estimate\"], Geom.line),\n    layer(ys, x=:x, ymin=:y_min, ymax=:y_max, color=[\"95% Confidence Interval\"], Geom.ribbon),\n    Guide.xlabel(\"time\"),\n    Guide.ylabel(\"y\"),\n    Coord.cartesian(xmin=1),\n)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Gaussian-Distributions","page":"Library Reference","title":"Gaussian Distributions","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"GaussianDistribution\nGaussianDistribution(Σ::AbstractMatrix, μ::AbstractVector)\nGaussianDistribution(Σ::AbstractMatrix)\nGaussianDistribution(μ::AbstractVector)\n\nOpenGaussianDistribution\nOpenGaussianDistribution(L::AbstractMatrix, R::AbstractMatrix, ψ::GaussianDistribution)\nOpenGaussianDistribution(L::AbstractMatrix, ψ::GaussianDistribution)\nOpenGaussianDistribution(L::AbstractMatrix)\nOpenGaussianDistribution(ψ::GaussianDistribution)\n\nGaussDom\n\nparams\ncov\nmean","category":"page"},{"location":"api/#AlgebraicInference.GaussianDistribution","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(cgf)\n\nA multivariate Gaussian distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.GaussianDistribution-Tuple{AbstractMatrix, AbstractVector}","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(Σ::AbstractMatrix, μ::AbstractVector)\n\nConstruct a Gaussian distribution with covariance Σ and mean μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussianDistribution-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(Σ::AbstractMatrix)\n\nConstruct a centered Gaussian distribution with covariance Σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussianDistribution-Tuple{AbstractVector}","page":"Library Reference","title":"AlgebraicInference.GaussianDistribution","text":"GaussianDistribution(μ::AbstractVector)\n\nConstruct a Dirac distribution with mean μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenGaussianDistribution","page":"Library Reference","title":"AlgebraicInference.OpenGaussianDistribution","text":"OpenGaussianDistribution(rf)\n\nAn open Gaussian distribution is a decorated cospan\n\nleft(\nbeginaligned\nbeginCD\nm   L k R n\nendCD\nendaligned\nenspace\nbeginaligned\nmathcalN(mu Sigma)\nendaligned\nright)\n\nwhere L, R are matrices and mathcalN(mu Sigma) is a Gaussian distribution on mathbbR^k. This data determines a morphism\n\nd m to n\n\nin the hypergraph category textCond(textGaussEx). In particular, if m = 0, then d represents the posterior distribution\n\nX mid Y = 0\n\nof a Bayesian model\n\nbeginalign*\nX           sim mathcalU \nepsilon   sim mathcalN(mu Sigma) \nY           = RX - epsilon\nendalign*\n\nwhere mathcalU is an improper uniform prior over mathbbR^n and X perp epsilon.\n\nReferences:\n\nStein & Staton (2021), \"Compositional Semantics for Probabilistic Programs with Exact Conditioning\" (arXiv:2101.11351)\nStein (2022), \"Decorated Linear Relations: Extending Gaussian Probability with Uninformative Priors\" (arXiv:2204.14024)\nStein (2022), \"A Hypergraph Category for Exact Gaussian Inference\", (https://msp.cis.strath.ac.uk/act2022/papers/ACT2022paper3601.pdf)\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.OpenGaussianDistribution-Tuple{AbstractMatrix, AbstractMatrix, GaussianDistribution}","page":"Library Reference","title":"AlgebraicInference.OpenGaussianDistribution","text":"OpenGaussianDistribution(L::AbstractMatrix, R::AbstractMatrix, ψ::GaussianDistribution)\n\nConstruct an open Gaussian distribution with legs (L, R) and decoration ψ.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenGaussianDistribution-Tuple{AbstractMatrix, GaussianDistribution}","page":"Library Reference","title":"AlgebraicInference.OpenGaussianDistribution","text":"OpenGaussianDistribution(L::AbstractMatrix, ψ::GaussianDistribution)\n\nConstruct the Gaussian map\n\nx mapsto Lx + psi\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenGaussianDistribution-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.OpenGaussianDistribution","text":"OpenGaussianDistribution(L::AbstractMatrix)\n\nConstruct the linear map\n\nx mapsto Lx\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenGaussianDistribution-Tuple{GaussianDistribution}","page":"Library Reference","title":"AlgebraicInference.OpenGaussianDistribution","text":"OpenGaussianDistribution(ψ::GaussianDistribution)\n\nConstruct the Gaussian map\n\n* mapsto psi\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.GaussDom","page":"Library Reference","title":"AlgebraicInference.GaussDom","text":"GaussDom(n)\n\nThe Euclidean space mathbbR^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.params","page":"Library Reference","title":"StatsAPI.params","text":"params(d::OpenGaussianDistribution)\n\nCompute the cumulant-generating function K of d.\n\nReturns a quadruple (Q a B b). If b neq 0, then K = -infty. Otherwise,\n\nK(x y) =\nbegincases\nlangle (x y) frac12Q(x y) + a rangle    B(x y) = 0 \ninfty                                              textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.cov","page":"Library Reference","title":"Statistics.cov","text":"cov(ψ::GaussianDistribution)\n\nGet the covariance of ψ.\n\n\n\n\n\ncov(d::OpenGaussianDistribution)\n\nGet the covariance of d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean","page":"Library Reference","title":"Statistics.mean","text":"mean(ψ::GaussianDistribution)\n\nGet the mean of ψ.\n\n\n\n\n\nmean(d::OpenGaussianDistribution)\n\nGet the mean of d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Quadratic-Functions","page":"Library Reference","title":"Quadratic Functions","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"QuadraticFunction\nQuadraticFunction(Q::AbstractMatrix)\nQuadraticFunction(a::AbstractVector)\n\nOpenQuadraticFunction\nOpenQuadraticFunction(L::AbstractMatrix, f::QuadraticFunction)\nOpenQuadraticFunction(L::AbstractMatrix)\nOpenQuadraticFunction(f::QuadraticFunction)\n\nQuadDom\n\n*\nconjugate","category":"page"},{"location":"api/#AlgebraicInference.QuadraticFunction","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(Q, a)\n\nA convex quadratic function of the form\n\nf(x) = langle x Qx + a rangle\n\nwhere Q is positive semidefinite.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.QuadraticFunction-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(Q::AbstractMatrix)\n\nConstruct the convex quadratic function \n\nf(x) = langle x Qx rangle\n\nwhere Q is positive semidefinite.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadraticFunction-Tuple{AbstractVector}","page":"Library Reference","title":"AlgebraicInference.QuadraticFunction","text":"QuadraticFunction(a::AbstractVector)\n\nConstruct the linear function\n\nf(x) = langle x a rangle\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenQuadraticFunction","page":"Library Reference","title":"AlgebraicInference.OpenQuadraticFunction","text":"OpenQuadraticFunction(L, R, f)\n\nAn open quadratic function is a decorated cospan\n\nleft(\nbeginaligned\nbeginCD\nm   L k R n\nendCD\nendaligned\nenspace\nbeginaligned\nf\nendaligned\nright)\n\nwhere L, R are matrices and f mathbbR^k to mathbbR is a convex quadratic function. This data determines a convex bifunction\n\nF(x y) = f^*(Ry - Lx)\n\nwhere f^* is the convex conjuate of f.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicInference.OpenQuadraticFunction-Tuple{AbstractMatrix, QuadraticFunction}","page":"Library Reference","title":"AlgebraicInference.OpenQuadraticFunction","text":"OpenQuadraticFunction(L::AbstractMatrix, f::QuadraticFunction)\n\nConstruct the bifunction\n\nF(x y) = f^*(y - Lx)\n\nwhere f^* is the convex conjugate of f.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenQuadraticFunction-Tuple{AbstractMatrix}","page":"Library Reference","title":"AlgebraicInference.OpenQuadraticFunction","text":"OpenQuadraticFunction(L::AbstractMatrix)\n\nConstruct the indicator bifunction corresponding to L, given by\n\nF(x y) =\nbegincases\n0        Lx = y \ninfty  textelse\nendcases\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.OpenQuadraticFunction-Tuple{QuadraticFunction}","page":"Library Reference","title":"AlgebraicInference.OpenQuadraticFunction","text":"OpenQuadraticFunction(f::QuadraticFunction)\n\nConstruct the bifunction \n\nF(* y) = f^*(y)\n\nwhere f^* is the convex conjugate of f.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInference.QuadDom","page":"Library Reference","title":"AlgebraicInference.QuadDom","text":"QuadDom(n)\n\nThe Euclidian space mathbbR^n.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*","page":"Library Reference","title":"Base.:*","text":"*(f::QuadraticFunction, M::Union{UniformScaling, AbstractMatrix})\n\nCompute the inverse image of f under M, given by\n\n(fM)(y) = f(My)\n\n\n\n\n\n*(M::Union{UniformScaling, AbstractMatrix}, f::QuadraticFunction)\n\nCompute the image of f under M, given by\n\n(Mf)(y) = inf  f(x) mid y = Mx \n\nReturns a quintuple (Q a alpha B b) If b neq 0, then Mf = -infty. Otherwise,\n\n(Mf)(y) =\nbegincases\nlangle y frac12Qy + a rangle + alpha    By = 0 \ninfty                                              textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicInference.conjugate","page":"Library Reference","title":"AlgebraicInference.conjugate","text":"conjugate(F::OpenQuadraticFunction)\n\nCompute the convex conjugate of F.\n\nReturns a quintuple (Q a alpha B b) If b neq 0, then F^* = -infty. Otherwise,\n\nF^*(x y) =\nbegincases\nlangle (x y) frac12Q(x y) + a rangle + alpha  B(x y) = 0 \ninfty                                                      textelse\nendcases\n\n\n\n\n\n","category":"function"},{"location":"api/#Composition","page":"Library Reference","title":"Composition","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"compose\noplus\nmeet\njoin\noapply","category":"page"},{"location":"api/#Catlab.Theories.compose","page":"Library Reference","title":"Catlab.Theories.compose","text":"compose(F₁::OpenQuadraticFunction, F₂::OpenQuadraticFunction)\n\nCompute the product of F₁ and F₂, given by\n\n(F_2F_1)(x z) = inf  F_1(x y) + F_2(y z) mid y \n\n\n\n\n\ncompose(d₁::OpenGaussianDistribution, d₂::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.oplus","page":"Library Reference","title":"Catlab.Theories.oplus","text":"oplus(f₁::QuadraticFunction, f₂::QuadraticFunction)\n\nCompute the direct sum of f₁ and f₂, given by \n\n(f_1 oplus f_2)(x y) = f_1(x) + f_2(y)\n\n\n\n\n\noplus(X::QuadDom, Y::QuadDom)\n\nCompute the direct sum of X and Y.\n\n\n\n\n\noplus(F₁::OpenQuadraticFunction, F₂::OpenQuadraticFunction)\n\nCompute the direct sum of F₁ and F₂, given by\n\n(F_1 oplus F_2)((x_1 x_2) (y_1 y_2)) = F_1(x_1 y_1) + F_2(x_2 y_2)\n\n\n\n\n\noplus(X::GaussDom, Y::GassDom)\n\nCompute direct sum of X and Y.\n\n\n\n\n\noplus(d₁::OpenGaussianDistribution, d₂::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.meet","page":"Library Reference","title":"Catlab.Theories.meet","text":"meet(F₁::OpenQuadraticFunction, F₂::OpenQuadraticFunction)\n\nCompute the sum of F₁ and F₂, given by\n\n(F_1 + F_2)(x y) = F_1(x y) + F_2(x y)\n\n\n\n\n\nmeet(d₁::OpenGaussianDistribution, d₂::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.join","page":"Library Reference","title":"Base.join","text":"join(F₁::OpenQuadraticFunction, F₂::OpenQuadraticFunction)\n\nCompute the infimal convolution of F₁  and F₂, given by\n\n(F_1  Box  F_2)(x^* y^*) = inf  F_1(x^* y^*) + F_2(x - x^* y - y^*) mid x y \n\n\n\n\n\njoin(d₁::OpenGaussianDistribution, d₂::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"oapply(composite::UndirectedWiringDiagram, hom_map::AbstractDict{T₁, T₂}) where {T₁, T₂ <: OpenQuadraticFunction}\n\nCompose open quadratic functions according to an undirected wiring wiring diagram.\n\n\n\n\n\noapply(composite::UndirectedWiringDiagram, cospans::AbstractVector{T}) where T <: OpenQuadraticFunction\n\nCompose open quadratic functions according to an undirected wiring wiring diagram.\n\n\n\n\n\noapply(composite::UndirectedWiringDiagram, hom_map::AbstractDict{T₁, T₂}) where {T₁, T₂ <: OpenGaussianDistribution}\n\nCompose open Gaussian distributions according to an undirected wiring wiring diagram.\n\n\n\n\n\noapply(composite::UndirectedWiringDiagram, cospans::AbstractVector{T}) where T <: OpenGaussianDistribution\n\nCompose open Gaussian distributions according to an undirected wiring wiring diagram.\n\n\n\n\n\n","category":"function"},{"location":"api/#Construction","page":"Library Reference","title":"Construction","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"mzero\nid\nswap\nzero\ncozero\ndelete\ncreate\nmcopy\nmmerge\nplus\ncoplus\ndunit\ndcounit\ntop\nbottom","category":"page"},{"location":"api/#Catlab.Theories.mzero","page":"Library Reference","title":"Catlab.Theories.mzero","text":"mzero(::Type{QuadDom})\n\nConstruct the Euclidean space mathbbR^0.\n\n\n\n\n\nmzero(::Type{GaussDom})\n\nConstruct the Euclidean space mathbbR^0.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.id","page":"Library Reference","title":"Catlab.Theories.id","text":"id(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x y) =\nbegincases\n0        x = y \ninfty  textelse\nendcases\n\n\n\n\n\nid(X::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.swap","page":"Library Reference","title":"Catlab.Theories.swap","text":"swap(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) (y_1 y_2)) =\nbegincases\n0        x_1 = y_2 x_2 = y_1 \ninfty  textelse\nendcases\n\n\n\n\n\nswap(X::GaussDom, Y::GaussDom)\n\nConstruct the linear map\n\n(x_1 x_2) mapsto (x_2 x_1)\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.zero","page":"Library Reference","title":"Base.zero","text":"zero(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(* y) =\nbegincases\n0        y = 0 \ninfty  textelse\nendcases\n\n\n\n\n\nzero(X::GaussDom)\n\nConstruct the linear map\n\n* mapsto 0\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.cozero","page":"Library Reference","title":"Catlab.Theories.cozero","text":"cozero(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x *) =\nbegincases\n0        x = 0 \ninfty  textelse\nendcases\n\n\n\n\n\ncozero(X::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.delete","page":"Library Reference","title":"Catlab.Theories.delete","text":"delete(X::QuadDom)\n\nConstruct the indicator bifunction \n\nF(x *) = 0\n\n\n\n\n\ndelete(X::GaussDom)\n\nConstruct the linear map\n\nx mapsto *\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.create","page":"Library Reference","title":"Catlab.Theories.create","text":"create(X::QuadDom)\n\nConstruct the indicator bifunction \n\nF(* y) = 0\n\n\n\n\n\ncreate(X::GaussDom)\n\nConstruct the extended Gaussian map\n\n* mapsto mathbbR^n\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.mcopy","page":"Library Reference","title":"Catlab.Theories.mcopy","text":"mcopy(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x (y_1 y_2)) =\nbegincases\n0        x = y_1 = y_2 \ninfty  textelse\nendcases\n\n\n\n\n\nmcopy(X::GaussDom)\n\nConstruct the linear map\n\nx mapsto (x x)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.mmerge","page":"Library Reference","title":"Catlab.Theories.mmerge","text":"mmerge(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) =\nbegincases\n0        x_1 = x_2 = y \ninfty  textelse\nendcases\n\n\n\n\n\nmmerge(X::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.plus","page":"Library Reference","title":"Catlab.Theories.plus","text":"plus(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) =\nbegincases\n0        x_1 + x_2 = y \ninfty  textelse\nendcases\n\n\n\n\n\nplus(X::GaussDom)\n\nConstruct the linear map\n\n(x y) mapsto x + y\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.coplus","page":"Library Reference","title":"Catlab.Theories.coplus","text":"coplus(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) y) =\nbegincases\n0        x_1 + x_2 = y \ninfty  textelse\nendcases\n\n\n\n\n\ncoplus(X::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dunit","page":"Library Reference","title":"Catlab.Theories.dunit","text":"dunit(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF(* (y_1 y_2)) =\nbegincases\n0        y_1 = y_2 \ninfty  textelse\nendcases\n\n\n\n\n\ndunit(X::GaussDom)\n\nConstruct the extended Gaussian map\n\n* mapsto (y y) mid y \n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dcounit","page":"Library Reference","title":"Catlab.Theories.dcounit","text":"dcounit(X::QuadDom)\n\nConstruct the indicator bifunction\n\nF((x_1 x_2) *) =\nbegincases\n0        x_1 = x_2 \ninfty  textelse\nendcases\n\n\n\n\n\ndcounit(X::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.top","page":"Library Reference","title":"Catlab.Theories.top","text":"top(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction  math F(x y) = 0`\n\n\n\n\n\ntop(X::GaussDom, Y::GaussDom)\n\nConstruct the extended Gaussian map\n\nx mapsto mathbbR^n\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.bottom","page":"Library Reference","title":"Catlab.Theories.bottom","text":"bottom(X::QuadDom, Y::QuadDom)\n\nConstruct the indicator bifunction\n\nF(x y) =\nbegincases\n0        x = y = 0 \ninfty  textelse\nendcases\n\n\n\n\n\nbottom(X::GaussDom, Y::GaussDom)\n\n\n\n\n\n","category":"function"},{"location":"api/#Other","page":"Library Reference","title":"Other","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"dom\ncodom\ndagger","category":"page"},{"location":"api/#Catlab.Schemas.dom","page":"Library Reference","title":"Catlab.Schemas.dom","text":"dom(F::OpenQuadraticFunction)\n\nThe domain of a bifunction is the dimension of its first variable.\n\n\n\n\n\ndom(d::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Schemas.codom","page":"Library Reference","title":"Catlab.Schemas.codom","text":"codom(F::OpenQuadraticFunction)\n\nThe codomain of a bifunction is the dimension of its second variable.\n\n\n\n\n\ncodom(d::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.Theories.dagger","page":"Library Reference","title":"Catlab.Theories.dagger","text":"dagger(F::OpenQuadraticFunction)\n\nCompute the dagger of F, given by\n\nF^dagger(y x) = F(x y)\n\n\n\n\n\ndagger(d::OpenGaussianDistribution)\n\n\n\n\n\n","category":"function"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/regression.jl\"","category":"page"},{"location":"generated/regression/#Bayesian-Linear-Regression","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"","category":"section"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing Convex\nusing DataFrames\nusing Fontconfig\nusing Gadfly\nusing SCS\nusing TikzPictures","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"The diagram posterior_diagram represents the posterior weights of a Bayesian linear regression model.","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"const F = FreeAbelianBicategoryRelations\n\nW  = Ob(F, :W)\nY  = Ob(F, :Y)\nw  = Hom(:w, mzero(F.Ob), W)\nϵ  = Hom(Symbol(\"\\\\epsilon\"), mzero(F.Ob), Y)\ny  = Hom(:y, mzero(F.Ob), Y)\nΦ  = Hom(Symbol(\"\\\\Phi\"), W, Y)\n\nposterior_diagram = (\n    w\n    ⋅ Δ(W)\n    ⋅ (y ⊕ ϵ ⊕ Φ ⊕ id(W))\n    ⋅ (id(Y) ⊕ plus(Y) ⊕ id(W))\n    ⋅ (dcounit(Y) ⊕ id(W))\n)\n\nto_tikz(posterior_diagram;\n    orientation=LeftToRight,\n    base_unit=\"6mm\",\n    props=[\"font=\\\\Large\", \"semithick\"]\n)","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"We assign values to the boxes in posterior_diagram.","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"beginalign*\nw         = mathcalN(0 05I) \nepsilon  = mathcalN(0 004I) \nPhi(w)   = beginbmatrix phi(076)  phi(050)  phi(093)  phi(038) endbmatrix^textT w \ny         = (-103 -002 -031 051)\nendalign*","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"where phi is a vector of nine Gaussian basis functions and y is a vector of noisy measurements from the function","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"f(x) = sin (2 pi x)","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"Then we compute the posterior weights.","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"parameters = [\n    (0.0, 0.1),\n    (0.5, 0.1),\n    (1.0, 0.1),\n    (0.0, 0.5),\n    (0.5, 0.5),\n    (1.0, 0.5),\n    (0.0, 2.5),\n    (0.5, 2.5),\n    (1.0, 2.5),\n]\n\nϕ(x) = [exp(-(x - μ)^2 / σ^2 / 2) for (μ, σ) in parameters]\n\nob_map = Dict(\n    W => GaussDom(9),\n    Y => GaussDom(4),\n)\n\nhom_map = Dict(\n    w => OpenGaussianDistribution(GaussianDistribution(\n        [\n            .5  0   0   0   0   0   0   0   0\n            0   .5  0   0   0   0   0   0   0\n            0   0   .5  0   0   0   0   0   0\n            0   0   0   .5  0   0   0   0   0\n            0   0   0   0   .5  0   0   0   0\n            0   0   0   0   0   .5  0   0   0\n            0   0   0   0   0   0   .5  0   0\n            0   0   0   0   0   0   0   .5  0\n            0   0   0   0   0   0   0   0   .5\n        ],\n    )),\n    ϵ => OpenGaussianDistribution(GaussianDistribution(\n        [\n            .04 0   0   0\n            0   .04 0   0\n            0   0   .04 0\n            0   0   0   .04\n        ],\n    )),\n    y => OpenGaussianDistribution(GaussianDistribution(\n        [-1.03, -0.02, -0.31, 0.51],\n    )),\n    Φ => OpenGaussianDistribution(\n        hcat(map(ϕ, [0.76, 0.50, 0.93, 0.38])...)',\n    ),\n)\n\nposterior = functor(\n    (GaussDom, OpenGaussianDistribution),\n    posterior_diagram;\n    generators = merge(ob_map, hom_map),\n)\n\nround.(mean(posterior); digits=2)","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"round.(cov(posterior); digits=2)","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"Finally, we plot estimated values against true values and measurements.","category":"page"},{"location":"generated/regression/","page":"Bayesian Linear Regression","title":"Bayesian Linear Regression","text":"measurements = DataFrame(\n    x = [0.76, 0.50, 0.93, 0.38],\n    y = [-1.03, -0.02, -0.31, 0.51],\n)\n\nys = DataFrame(\n    map(range(0, 1, 100)) do x\n        ob_map = Dict(\n            W => GaussDom(9),\n            Y => GaussDom(1),\n        )\n\n        hom_map = Dict(\n            w => posterior,\n            ϵ => OpenGaussianDistribution(GaussianDistribution([.04;;])),\n            Φ => OpenGaussianDistribution([ϕ(x)...;;]),\n        )\n\n        estimate = functor(\n            (GaussDom, OpenGaussianDistribution),\n            w ⋅ (ϵ ⊕ Φ) ⋅ plus(Y);\n            generators = merge(ob_map, hom_map),\n        )\n\n        μ = mean(estimate)[1]\n        σ = √cov(estimate)[1]\n        (x=x, y_true=sin(2π * x), y_pred=μ, y_min=μ-2σ, y_max=μ+2σ)\n    end\n)\n\nset_default_plot_size(23cm, 10cm)\n\nplot(\n    layer(measurements, x=:x, y=:y, color=[\"measurements\"], Geom.point),\n    layer(ys, x=:x, y=:y_true, color=[\"true values\"], Geom.line),\n    layer(ys, x=:x, y=:y_pred, ymin=:y_min, ymax=:y_max, color=[\"estimates\"], Geom.line, Geom.ribbon),\n    Coord.cartesian(xmin=0, xmax=1, ymin=-2, ymax=2),\n    Guide.xlabel(\"x\"),\n    Guide.ylabel(\"y\"),\n)","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/filter_directed.jl\"","category":"page"},{"location":"generated/filter_directed/#Kalman-Filter-–-Directed","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"","category":"section"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing Convex\nusing DataFrames\nusing Fontconfig\nusing Gadfly\nusing SCS\nusing TikzPictures","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"The directed wiring diagram filter_diagram represents estimated state after five iterations of a one-dimensional Kalman filter.","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"const F = FreeAbelianBicategoryRelations\n\nℝ = Ob(F, :ℝ)\ns₀ = Hom(:s_0, mzero(F.Ob), ℝ)\ny₁ = Hom(:y_1, mzero(F.Ob), ℝ)\ny₂ = Hom(:y_2, mzero(F.Ob), ℝ)\ny₃ = Hom(:y_3, mzero(F.Ob), ℝ)\ny₄ = Hom(:y_4, mzero(F.Ob), ℝ)\nq = Hom(:q, mzero(F.Ob), ℝ)\nr = Hom(:r, mzero(F.Ob), ℝ)\n\ncircuitry = (\n    (plus(ℝ) ⋅ Δ(ℝ) ⊕ id(ℝ) ⊕ id(ℝ))\n    ⋅ (id(ℝ) ⊕ plus(ℝ) ⊕ id(ℝ))\n    ⋅ (id(ℝ) ⊕ dcounit(ℝ))\n)\n\nfilter_diagram = (\n    s₀\n    ⋅ (id(ℝ) ⊕ q ⊕ r ⊕ y₁) ⋅ circuitry\n    ⋅ (id(ℝ) ⊕ q ⊕ r ⊕ y₂) ⋅ circuitry\n    ⋅ (id(ℝ) ⊕ q ⊕ r ⊕ y₃) ⋅ circuitry\n    ⋅ (id(ℝ) ⊕ q ⊕ r ⊕ y₄) ⋅ circuitry\n    ⋅ (id(ℝ) ⊕ q) ⋅ plus(ℝ)\n)\n\nto_tikz(filter_diagram;\n    orientation=TopToBottom,\n    base_unit=\"6mm\",\n    props=[\"font=\\\\Large\", \"semithick\"],\n)","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"We assign values to the boxes in filter_diagram according to Example 6 of this tutorial.","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"beginalign*\ns_0   = mathcalN(60 10000) \nq     = mathcalN(0 00001) \nr     = mathcalN(0 001) \ny_1   = 49986 \ny_2   = 49963 \ny_3   = 50090 \ny_4   = 50001 \nendalign*","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"where (y_1 dots y_4) are noisy measurements of the points","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"(50005 49994 49993 50001)","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"Then we estimate the state at time t = 5.","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"ob_map = Dict(\n    ℝ   => GaussDom(1),\n)\n\nhom_map = Dict(\n    s₀  => OpenGaussianDistribution(GaussianDistribution([10000;;], [60])),\n    y₁  => OpenGaussianDistribution(GaussianDistribution([49.986])),\n    y₂  => OpenGaussianDistribution(GaussianDistribution([49.963])),\n    y₃  => OpenGaussianDistribution(GaussianDistribution([50.090])),\n    y₄  => OpenGaussianDistribution(GaussianDistribution([50.001])),\n    q   => OpenGaussianDistribution(GaussianDistribution([0.0001;;])),\n    r   => OpenGaussianDistribution(GaussianDistribution([0.01;;])),\n)\n\nstate = functor(\n    (GaussDom, OpenGaussianDistribution),\n    filter_diagram;\n    generators = merge(ob_map, hom_map),\n)\n\nμ = mean(state)[1]\nσ = √cov(state)[1]\n\nprint(\"N($μ, $σ)\")","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"Finally, we plot our estimate against the true value at time t = 5.","category":"page"},{"location":"generated/filter_directed/","page":"Kalman Filter – Directed","title":"Kalman Filter – Directed","text":"pdf = DataFrame(\n    x = range(49.6, 50.4, 100),\n    y = map(x -> exp(-.5(x - μ)^2 / σ^2) / σ / √(2π), range(49.6, 50.4, 100)),\n)\n\nset_default_plot_size(23cm, 10cm)\n\nplot(\n    layer(pdf, x=:x, y=:y, color=[\"estimate\"], Geom.line),\n    layer(xintercept=[50.006], color=[\"true value\"], Geom.vline),\n    Guide.xlabel(\"Temperature (Cᵒ)\"),\n)","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/filter_undirected.jl\"","category":"page"},{"location":"generated/filter_undirected/#Kalman-Filter-–-Undirected","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"","category":"section"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing DataFrames\nusing Fontconfig\nusing Gadfly","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"The undirected wiring diagram filter_diagram represents estimated state after five iterations of a one-dimensional Kalman filter.","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"filter_diagram = @relation (X₅,) begin\n    s₀(X₀)\n    y₁(Y₁)\n    y₂(Y₂)\n    y₃(Y₃)\n    y₄(Y₄)\n    s(X₀, X₁)\n    s(X₁, X₂)\n    s(X₂, X₃)\n    s(X₃, X₄)\n    s(X₄, X₅)\n    m(X₁, Y₁)\n    m(X₂, Y₂)\n    m(X₃, Y₃)\n    m(X₄, Y₄)\nend\n\nto_graphviz(filter_diagram; box_labels = :name)","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"We assign values to the boxes in filter_diagram according to Example 6 of this tutorial.","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"beginalign*\ns_0   = mathcalN(60 10000) \ns(x)  = mathcalN(x 00001) \nm(x)  = mathcalN(x 001) \ny_1   = 49986 \ny_2   = 49963 \ny_3   = 50090 \ny_4   = 50001 \nendalign*","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"where (y_1 dots y_5) are noisy measurements of the points","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"(50005 49994 49993 50001)","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"Then we estimate the state at time t = 5.","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"hom_map = Dict(\n    :s₀  => OpenGaussianDistribution(GaussianDistribution([10000;;], [60])),\n    :y₁  => OpenGaussianDistribution(GaussianDistribution([49.986])),\n    :y₂  => OpenGaussianDistribution(GaussianDistribution([49.963])),\n    :y₃  => OpenGaussianDistribution(GaussianDistribution([50.090])),\n    :y₄  => OpenGaussianDistribution(GaussianDistribution([50.001])),\n    :s   => OpenGaussianDistribution([1;;], GaussianDistribution([0.0001;;])),\n    :m   => OpenGaussianDistribution([1;;], GaussianDistribution([0.01;;])),\n)\n\nstate = oapply(filter_diagram, hom_map)\nμ = mean(state)[1]\nσ = √cov(state)[1]\n\nprint(\"N($μ, $σ)\")","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"Finally, we plot our estimate against the true value at time t = 5.","category":"page"},{"location":"generated/filter_undirected/","page":"Kalman Filter – Undirected","title":"Kalman Filter – Undirected","text":"pdf = DataFrame(\n    x = range(49.6, 50.4, 100),\n    y = map(x -> exp(-.5(x - μ)^2 / σ^2) / σ / √(2π), range(49.6, 50.4, 100)),\n)\n\nset_default_plot_size(23cm, 10cm)\n\nplot(\n    layer(pdf, x=:x, y=:y, color=[\"estimate\"], Geom.line),\n    layer(xintercept=[50.006], color=[\"true value\"], Geom.vline),\n    Guide.xlabel(\"Temperature (Cᵒ)\"),\n)","category":"page"},{"location":"#AlgebraicInference.jl","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"","category":"section"},{"location":"","page":"AlgebraicInference.jl","title":"AlgebraicInference.jl","text":"AlgebraicInference.jl is a library for compositional Bayesian inference. It builds on Catlab.jl.","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"EditURL = \"https://github.com/samuelsonric/AlgebraicInference.jl/blob/master/docs/literate/inference.jl\"","category":"page"},{"location":"generated/inference/#Bayesian-Inference","page":"Bayesian Inference","title":"Bayesian Inference","text":"","category":"section"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"using AlgebraicInference\nusing Cairo\nusing Catlab, Catlab.Theories, Catlab.Graphics, Catlab.Programs\nusing DataFrames\nusing Fontconfig\nusing Gadfly","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"The undirected wiring diagram posterior_diagram represents the posterior distribution","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Y mid X = textevidence","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"of a generative model","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"beginalign*\nX         sim textprior \nY mid X  sim textlikelihood\nendalign*","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"posterior_diagram = @relation (X,) begin\n    prior(X)\n    likelihood(X, Y)\n    evidence(Y)\nend\n\nto_graphviz(posterior_diagram; box_labels = :name)","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"We assign values to the nodes in posterior_diagram.","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"beginalign*\ntextprior          = mathcalN(0 1) \ntextlikelihood(x)  = mathcalN(2x 05) \ntextevidence       = 3\nendalign*","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Then we compute the posterior","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Y mid X = 3","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"hom_map = Dict(\n    :prior      => OpenGaussianDistribution(GaussianDistribution([1;;])),\n    :likelihood => OpenGaussianDistribution([2;;], GaussianDistribution([.5;;])),\n    :evidence   => OpenGaussianDistribution(GaussianDistribution([3])),\n)\n\nposterior = oapply(posterior_diagram, hom_map)\nμ = mean(posterior)[1]\nσ = √cov(posterior)[1]\n\n(round(μ), round(σ^2))","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"Finally, we plot the posterior against the prior.","category":"page"},{"location":"generated/inference/","page":"Bayesian Inference","title":"Bayesian Inference","text":"pdfs = DataFrame(\n    x = range(-5, 5, 100),\n    y₀ = map(x -> exp(-.5x^2) / √(2π), range(-5, 5, 100)),\n    y₁ = map(x -> exp(-.5(x - μ)^2 / σ^2) / σ / √(2π), range(-5, 5, 100)),\n)\n\nset_default_plot_size(23cm, 10cm)\n\nplot(\n    layer(pdfs, x=:x, y=:y₀, color=[\"prior\"], Geom.line),\n    layer(pdfs, x=:x, y=:y₁, color=[\"posterior\"], Geom.line),\n    Guide.xlabel(\"x\"),\n    Guide.ylabel(\"\"),\n)","category":"page"}]
}
